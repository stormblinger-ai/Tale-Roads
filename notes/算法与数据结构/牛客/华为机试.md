# 字符串

##  1，字符串分隔

+ 暴力加切片，把所有情况列出来，依次解决

![image-20221228175824040](D:\工具\Typora\image\image-20221228175824040.png)

+ pass

- 常见错误

  - [x] for循环里range里面要用int

    

## 2，进制转换

- 其他进制转换为十进制

![image-20221228183333582](D:\工具\Typora\image\image-20221228183333582.png)

- [x] 注意函数要用while True 和try,,,except包围



## 3，字符个数统计

![image-20221228184811701](D:\工具\Typora\image\image-20221228184811701.png)

- input输入的是int类型要转换
- set（）可以去重，set长度用len可行



## 4，数值颠倒

![image-20221228191209281](D:\工具\Typora\image\image-20221228191209281.png)

- 使用input输入为str，转换为列表，列表反转，后拼接成字符串输出

- [x] 注意，input输入的为str
- [ ] 序列中只有列表可以反转用reverse，且要实际对象，表达式不行
- [ ] for循环中变量，不能拿出去直接用

## 5，字符串反转

- [ ] 接受一个只包含小写字母的字符串，反转输出，长度不超过1000

- [ ] 特殊情况：字符串只包含一个字母

- [ ] 空串,是否小写，是否纯字母

  

![image-20221229151147866](D:\工具\Typora\image\image-20221229151147866.png)

- [x] 输入转换为列表，反转后，join默认分隔符拼接列表中元素成新串
- [ ] 用join耗时比+拼接字符串要省时
- [ ] iter可迭代输出，但要指定输出结尾空格符
- [ ] enumerate会输出带计数的元素
- [ ] 还可以用切片进行反转列表

![image-20221229151949355](D:\工具\Typora\image\image-20221229151949355.png)

## 6，字符串排序

![image-20221229152342094](D:\工具\Typora\image\image-20221229152342094.png)

- [x] 注意事项，第一行输入的n是str，不可直接当int用
- [ ] 切片和直接输出列表，会整个输出，需要用循环遍历列表

![image-20221229160928850](D:\工具\Typora\image\image-20221229160928850.png)



## 7，字符串最后一个单词长度

![image-20221229161043174](D:\工具\Typora\image\image-20221229161043174.png)

- [x] 对输入的字符串进行split分割，注意输出的是长度

## 8，坐标移动

![image-20221229161821202](D:\工具\Typora\image\image-20221229161821202.png)



- [x] 暴力法，先分割，后分别判断方向和跨度是否合法，注意后面用isdigital判断是数字

![image-20221229192212099](D:\工具\Typora\image\image-20221229192212099.png)

- [x] 可改进条件控制语句，以及判断条件冗余

## 9，识别IP地址和子网掩码

![image-20221229192616373](D:\工具\Typora\image\image-20221229192616373.png)

- [x] 输入多行字符串

- [ ] IP地址和掩码用分隔符~隔开

- [ ] 输出七个结果值，a[0]*7

- [x] 0.开头和127.开头的IP地址忽略

- [x] 子网掩码，4个值，1，4个全是1；2,4个全是0；3，前面是连续1，后面连续0，即连续1为255，连续0

- [ ] A类，1~126.255，其中10~10.255是私有

- [ ] B类，128~191，其中172.16~172.31是私有

- [ ] C类，192~223，其中192.168是私有

- [ ] D类，224~239，

- [ ] E类，240~255

- [x] 处理输入数据

  -1，分割IP地址和子网掩码

  -2，子网掩码比对有误错误

  -3，IP地址再次分割

  ​		-分割后长度为4

  ​		-分割后每个值都是digital且都>0而<=255

  ​		-开头部位不为0或127

  ​		-
  
- [x] 输出，x[A,B,C,D,E,ERROR,P1]

## 10，入门题

- 取近似值

  写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。数据范围：保证输入的数字在 32 位浮点数范围内 

```
难度不大，有多种解法，Python数值类型：int,float, complex,int()和float()强制转换时，精度问题
注：有些语法问题得注意细节
1，标准输入输出
2，列表遍历方法
3，列表中元素类型和运算类型是否需要转换
4，输入浮点数，输出是整数，注意类型
5，是否需要异常语句

A.递推法
import sys
for line in sys.stdin:
    a = line.split()
for i in a:
    i = float(i)
    if (i % 1) >= 0.5:
        print(int(i // 1 + 1))
    else:
        print(int(i // 1))
B.直接浮点运算，向下取整类型转换
```

- 提取不重复的整数

  输入一个 int 型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 保证输入的整数最后一位不是 0 。数据范围： 1≤n≤108 1≤n≤108 

```
要求：int --> 处理 --->int
注：输入最后一位不为0，倒序不重复
1，列表里是字符串
2，列表反转实现，reverse，sort和索引实现
3，列表去重方法,set()不重复，无序，输出不固定。构造新列表或字符串
4，是否需要异常捕获以及return返回值
A.递推(暴力法)
import sys
for line in sys.stdin:
    a = line.split()
result = ''
for i in a:
    for x in range(1, len(i)+1):
        if i[-x] not in result:
            result += i[-x] 
print(int(result))
注：字符串逆序a = a[::-1]；
集合去重，必须按索引排序，不然顺序会乱，
set()先调用hash算法判断是否相等，相等时再用equls方法判断一次
list1 = list(input()[::-1])
list2 = list(set(list1))
list2.sort(key = list1.index)
print(''.join(list2))
```

- 截取字符串

  输入一个字符串和一个整数 k ，截取字符串的前k个字符并输出 。
  数据范围：字符串长度满足 1≤n≤1000 1≤n≤1000 ， 1≤k≤n 1≤k≤n 

```
要求：str[] k  -->截取处理 --> str[0,k]
字符串切片str[0,k],左闭右包，但是从0开始
输入两次有回车
注：需不需要考虑输入问题，K大于字符长度，或者为复数，这些判断需不需要加
result和cause，problem和solution
1，递推
cause = input()
k = input()
print(cause[:int(k)])
2，while True:
    try:
        str1 = input()
        k = int(input())
        print(str1[:k])
    except:
        break
```

- 输入n个整数，输出其中最小的K个
输入n个整数，找出其中最小的k个整数并按升序输出
本题有多组输入样例
数据范围：1≤n≤1000 1≤n≤1000  ，输入的整数满足 1≤val≤10000 1≤val≤10000 
```
要求：n个数，最小的前K个，数组  --> 排序 ---> 升序K个输出
处理输入，三个输入，
列表或数组排序，升序排列
输出直接输出前k个，切片
