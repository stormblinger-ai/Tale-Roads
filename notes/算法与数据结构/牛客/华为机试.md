# 字符串

## 常用方法

- 集合去重

``` 
set集合在内部执行时,首先会先对对象执行hash算法,存储到内存空间,，唯一且无序
(但在同一次运行过程中两个值相等的对象hash值一样)所以如果两个对象值相等,这时会做出第二步操作,
判断这两个对象的值是否相等,若相等覆盖,若不等则进行二次寻址,存储到空间
即先__hash__,后__equal__方法判断
ls = [1,2,33,345,2,3,33,5,5,4,4,45]
obj = list(set(ls))
obj.sort()
print(obj)
#结果:[1, 2, 3, 4, 5, 33, 45, 345]
```



- 输入input()和sys.stdin

```
1,输入的默认存储类型为str
2，用split函数分割后，转换为list列表，其内部元素为str
input直接过滤换行符，sys.stdin包含末尾换行符，但都只接收一行，即到换行符结束结束接收
```



- 内置排序sort()和sorted(),内置join

```
sort()排序默认升序排列，添加参数reverse=True，规则转换为降序排序，且改变原有列表
sorted()返回一个新列表，原列表不变
list.sort(key=None,reverse=False)   # 无返回值
list = sorted(iterable=None,key=None,reverse=False) # 返回新的列表，
内置字符串拼接+，join，format，fstring
+ 是两个字符拼接，会创建临时对象，浪费内存空间
join可直接拼接多个字符串，其他两个可以做格式化拼接字符创
List = ['AAA', 'BBB', 'CCC']
print("".join(List))
print(" ".join(List))
print("*".join(List))
# 以下输出结果和上述相同
print("---------------")
S = ""
S1 = " "
S2 = "*"
print(S.join(List))
print(S1.join(List))
print(S2.join(List))
```

- map转换

```
map()函数是Python中的一个内置函数，它的功能是：将指定的函数，依次作用于可迭代对象的每个元素，并返回一个迭代器对象。这个可迭代对象，可以是一个也可以是多个
map(function,iterable,...)
```

- 打印列表

```
*list,sep=' '打印
.join(list)打印
for 循环迭代打印
```



##  1，字符串分隔

+ 暴力加切片，把所有情况列出来，依次解决

![image-20221228175824040](D:\工具\Typora\image\image-20221228175824040.png)

+ pass

- 常见错误

  - [x] for循环里range里面要用int

    

## 2，进制转换

- 其他进制转换为十进制

![image-20221228183333582](D:\工具\Typora\image\image-20221228183333582.png)

- [x] 注意函数要用while True 和try,,,except包围



## 3，字符个数统计

![image-20221228184811701](D:\工具\Typora\image\image-20221228184811701.png)

- input输入的是int类型要转换
- set（）可以去重，set长度用len可行



## 4，数值颠倒

![image-20221228191209281](D:\工具\Typora\image\image-20221228191209281.png)

- 使用input输入为str，转换为列表，列表反转，后拼接成字符串输出

- [x] 注意，input输入的为str
- [ ] 序列中只有列表可以反转用reverse，且要实际对象，表达式不行
- [ ] for循环中变量，不能拿出去直接用

## 5，字符串反转

- [ ] 接受一个只包含小写字母的字符串，反转输出，长度不超过1000

- [ ] 特殊情况：字符串只包含一个字母

- [ ] 空串,是否小写，是否纯字母

  

![image-20221229151147866](D:\工具\Typora\image\image-20221229151147866.png)

- [x] 输入转换为列表，反转后，join默认分隔符拼接列表中元素成新串
- [ ] 用join耗时比+拼接字符串要省时
- [ ] iter可迭代输出，但要指定输出结尾空格符
- [ ] enumerate会输出带计数的元素
- [ ] 还可以用切片进行反转列表

![image-20221229151949355](D:\工具\Typora\image\image-20221229151949355.png)

## 6，字符串排序

![image-20221229152342094](D:\工具\Typora\image\image-20221229152342094.png)

- [x] 注意事项，第一行输入的n是str，不可直接当int用
- [ ] 切片和直接输出列表，会整个输出，需要用循环遍历列表

![image-20221229160928850](D:\工具\Typora\image\image-20221229160928850.png)



## 7，字符串最后一个单词长度

![image-20221229161043174](D:\工具\Typora\image\image-20221229161043174.png)

- [x] 对输入的字符串进行split分割，注意输出的是长度

## 8，坐标移动

![image-20221229161821202](D:\工具\Typora\image\image-20221229161821202.png)



- [x] 暴力法，先分割，后分别判断方向和跨度是否合法，注意后面用isdigital判断是数字

![image-20221229192212099](D:\工具\Typora\image\image-20221229192212099.png)

- [x] 可改进条件控制语句，以及判断条件冗余

## 9，识别IP地址和子网掩码

![image-20221229192616373](D:\工具\Typora\image\image-20221229192616373.png)

- [x] 输入多行字符串

- [ ] IP地址和掩码用分隔符~隔开

- [ ] 输出七个结果值，a[0]*7

- [x] 0.开头和127.开头的IP地址忽略

- [x] 子网掩码，4个值，1，4个全是1；2,4个全是0；3，前面是连续1，后面连续0，即连续1为255，连续0

- [ ] A类，1~126.255，其中10~10.255是私有

- [ ] B类，128~191，其中172.16~172.31是私有

- [ ] C类，192~223，其中192.168是私有

- [ ] D类，224~239，

- [ ] E类，240~255

- [x] 处理输入数据

  -1，分割IP地址和子网掩码

  -2，子网掩码比对有误错误

  -3，IP地址再次分割

  ​		-分割后长度为4

  ​		-分割后每个值都是digital且都>0而<=255

  ​		-开头部位不为0或127

  ​		-
  
- [x] 输出，x[A,B,C,D,E,ERROR,P1]

## 10，入门题

- 取近似值

  写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。数据范围：保证输入的数字在 32 位浮点数范围内 

```
难度不大，有多种解法，Python数值类型：int,float, complex,int()和float()强制转换时，精度问题
注：有些语法问题得注意细节
1，标准输入输出
2，列表遍历方法
3，列表中元素类型和运算类型是否需要转换
4，输入浮点数，输出是整数，注意类型
5，是否需要异常语句

A.递推法
import sys
for line in sys.stdin:
    a = line.split()
for i in a:
    i = float(i)
    if (i % 1) >= 0.5:
        print(int(i // 1 + 1))
    else:
        print(int(i // 1))
B.直接浮点运算，向下取整类型转换
```

- 提取不重复的整数

  输入一个 int 型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 保证输入的整数最后一位不是 0 。数据范围： 1≤n≤108 1≤n≤108 

```
要求：int --> 处理 --->int
注：输入最后一位不为0，倒序不重复
1，列表里是字符串
2，列表反转实现，reverse，sort和索引实现
3，列表去重方法,set()不重复，无序，输出不固定。构造新列表或字符串
4，是否需要异常捕获以及return返回值
A.递推(暴力法)
import sys
for line in sys.stdin:
    a = line.split()
result = ''
for i in a:
    for x in range(1, len(i)+1):
        if i[-x] not in result:
            result += i[-x] 
print(int(result))
注：字符串逆序a = a[::-1]；
集合去重，必须按索引排序，不然顺序会乱，
set()先调用hash算法判断是否相等，相等时再用equls方法判断一次
list1 = list(input()[::-1])
list2 = list(set(list1))
list2.sort(key = list1.index)
print(''.join(list2))
```

- 截取字符串

  输入一个字符串和一个整数 k ，截取字符串的前k个字符并输出 。
  数据范围：字符串长度满足 1≤n≤1000 1≤n≤1000 ， 1≤k≤n 1≤k≤n 

```
要求：str[] k  -->截取处理 --> str[0,k]
字符串切片str[0,k],左闭右包，但是从0开始
输入两次有回车
注：需不需要考虑输入问题，K大于字符长度，或者为复数，这些判断需不需要加
result和cause，problem和solution
1，递推
cause = input()
k = input()
print(cause[:int(k)])
2，while True:
    try:
        str1 = input()
        k = int(input())
        print(str1[:k])
    except:
        break
```

- 输入n个整数，输出其中最小的K个
输入n个整数，找出其中最小的k个整数并按升序输出
本题有多组输入样例
数据范围：1≤n≤1000 1≤n≤1000  ，输入的整数满足 1≤val≤10000 1≤val≤10000 
```
要求：n个数，最小的前K个，数组  --> 排序 ---> 升序K个输出
处理输入，三个输入，
列表或数组排序，升序排列
输出直接输出前k个，切片
import sys

n = input().split()
k = input().split()
s = []
for i in range(int(n[0])):
    s.append(int(k[i]))

s.sort()
for x in range(int(n[1])):
    print(s[x], end=" ")
```

- 输入整型数组和排序标识，对其元素按照升序或降序进行排序

  数据范围： 1≤n≤1000 1≤n≤1000 ，元素大小满足 0≤val≤100000 0≤val≤100000 


输入描述：

第一行输入数组元素个数
第二行输入待排序的数组，每个数用空格隔开
第三行输入一个整数0或1。0代表升序排序，1代表降序排序

输出描述：

输出排好序的数字

```
要求：三行输入，一行输出
个数，数组，0或1 --> 排序操作 --> 数组中数字
input()和sys.stdin函数得到的是字符串
split函数返回一个列表
sort函数默认升序排列，列表里是字符时，排序时默认按照字符首个大小依次往后排，所以建议用append添加到
列表里
注：for循环打印时，每运行一次都是以换行结尾的，while TRUE：try,,,except包裹
1，递推
num = int(input())
list = input().split()
rev = int(input())
s = []
for i in range(num):
    s.append(int(list[i]))
if rev == 1:
    s.sort(reverse=True)
else:
    s.sort()
for i in range(num):
    print(s[i], end=' ')
2，他法
n = int(input())
ls = list(map(int, input().split()))    # 需要转成整数，才能排序
rnk = int(input())
if rnk == 0:
    ls.sort()
    ls = map(str,ls)    # 需要转回字符串，才能拼接
    print(' '.join(ls))
elif rnk == 1:
    ls.sort(reverse=True)
    ls = map(str, ls)
    print(' '.join(ls))

```

## 11，简单题

- 1，字符串最后一个单词长度

输入描述：

输入一行，代表要计算的字符串，非空，长度小于5000。

输出描述：

输出一个整数，表示输入字符串最后一个单词的长度。

```
要求：输入字符串，输出长度
input接受，split分割 ---> 找到最后一个单词，计算长度用Len --> 输出
1，递推
cause = input().split()
print(len(cause[-1]))
注：while True: try...except:break。包围
能否自己写分割和求字符长度函数
输入判断异常过滤
内置函数和自己写函数，时间和空间复杂度
2，他人参考方法
指针从数组尾部向数组头部移动，判断并计算移动距离

去除字符串首尾空格，设置指针，从数组的末尾向数组头部移动，直至遇到空格或者遇到数组首位元素，此时指针移动距离即最后一个单词的长度

    去掉首尾空格
    指针从数组末尾开始移动，判断

    若所指元素为空格则停止移动，输出指针移动距离
    若不为空格，则向前移动，移动距离加一

时间复杂度分析： O(n)
空间复杂度分析： O(1)
代码
input_str = input().strip()
dis = 0
for i in range(len(input_str)-1, -1, -1):
  if input_str[i] == ' ':
    break
  dis += 1
print(dis)
```

